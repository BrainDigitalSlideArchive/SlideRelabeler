import multiprocessing.shared_memory
import os
import math
import io
import copy
import shutil
import sys
import tempfile
import ctypes
import pickle
import hashlib
import json
import logging
import base64
import xml.etree.ElementTree
from multiprocessing import shared_memory

from large_image_source_tiff import TiffFileTileSource
import qrcode
# '''
# To import pyvips in windows with 3.8+ you need to add the appropriate dlls to the path
# This part is altered from the original WSI DeiD codebase.
# '''

# Uncomment below if making production as these will be handled by pyinstaller.
# if os.name == 'nt':
#     class_dir = os.path.abspath(os.path.join(os.path.dirname(__file__)))
#     vips_bin_dir = os.path.join(class_dir, 'win-bin')
#     os.environ['PATH'] = os.pathsep.join((vips_bin_dir, os.environ['PATH']))
#     os.add_dll_directory(vips_bin_dir)

# import libtiff
import tifftools
# from large_image_source_tiff import TiffFileTileSource

import PIL

__version__ = '0.0.1'

from .wsi_deid_process import (
    get_generated_title,
    get_standard_redactions,
    redact_image_area,
    add_title_to_image,
    redact_topleft_square,
    determine_format,
    model_information,
    metadata_field_count,
    redact_format_philips_replace_macro,
    redact_format_hamamatsu_redact_wsi,
    redact_format_hamamatsu_replace_macro,
    redact_format_aperio_philips_redact_wsi,
    redact_format_aperio_add_image,
    redact_tiff_tags,
    add_deid_metadata,
    get_deid_field_dict,
    generate_system_redaction_list_entry,
    get_deid_field,
    PhilipsTagElements,
    philips_tag,
    dictToEtree
)

from . import config
from .file_io import TrackingFileIO
from .DeIdImageItem import DeIdImageItem as ImageItem

# TODO: fix/test text size in generated label.
# TODO: debug issue with libtiff large image source in MACOSX.

class DeidTools:
    processed_dir = None
    logger = None
    supress_print = False
    output_dir = None
    sep_height = 20
    pil_image_mode = "RGB"

    default_image = """
        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
        """

    def get_current_write_progress(self, input_path):
        output_path = self.current_write_files[input_path].filename
        output_file_stats = os.stat(output_path)
        output_file_size = output_file_stats.st_size

        input_file_stats = os.stat(input_path)
        input_file_size = input_file_stats.st_size

        perc = output_file_size / input_file_size

        return perc

    def aperio_value_list(self, item, redactList, title):
        """
        Get a list of aperio values that can be joined with | to form the aperio
        comment.

        :param item: the item to redact.
        :param redactList: the list of redactions (see get_redact_list).
        :param title: the new title for the item.
        """
        tileSource = item.tileSource  # MODIFIED
        metadata = tileSource.getInternalMetadata() or {}
        aperioDict = {}
        if 'openslide' in metadata:
            comment = metadata["openslide"]["openslide.comment"]
            aperioHeader = comment.split("|", 1)[0]
            # Add defaults for required aperio fields to this dictionary
            for fullkey, value in metadata["openslide"].items():
                if fullkey.startswith("aperio."):
                    redactKey = "internal;openslide;" + fullkey.replace("\\", "\\\\").replace(
                        ";", "\\;"
                    )
                    value = redactList["metadata"].get(redactKey, {}).get("value", value)
                    if value is not None and "|" not in value:
                        key = fullkey.split(".", 1)[1]
                        if key.startswith("CustomField."):
                            continue
                        aperioDict[key] = value

        # From DeID Upload information
        aperioDict.update(get_deid_field_dict(item))
        # Required values
        aperioDict.update(
            {
                "Filename": title,
                "Title": title,
            }
        )
        aperioValues = [aperioHeader] + [
            "%s = %s" % (k, v) for k, v in sorted(aperioDict.items())
        ]
        return aperioValues

    def add_text_to_image(self, image, title, previouslyAdded=False, minWidth=384,
                          background='#000000', textColor='#ffffff', square=True,
                          item=None):
        """
        Add a title to an image.  If the image doesn't exist, a new image is made
        the minimum width and appropriate height.  If the image does exist, a bar
        is added at its top to hold the title.  If an existing image is smaller
        than minWidth, it is pillarboxed to the minWidth.

        Rewritten from WSI DeiD given hardcoded font that is not available in windows.

        :param image: a PIL image or None.
        :param title: a text string.
        :param previouslyAdded: if true and modifying an image, don't allocate more
            space for the title; overwrite the top of the image instead.
        :param minWidth: the minimum width for the new image.
        :param background: the background color of the title and any necessary
            pillarbox.
        :param textColor: the color of the title text.
        :param square: if True, output a square image.
        :param item: the original item record.
        :returns: a PIL image.
        """
        title = title or ''
        if image is None:
            image = PIL.Image.new(self.pil_image_mode, (750, 750))
        image = image.convert(self.pil_image_mode)
        imageDrawFont = None
        w, h = image.size
        background = PIL.ImageColor.getcolor(background, self.pil_image_mode)
        textColor = PIL.ImageColor.getcolor(textColor, self.pil_image_mode)
        targetW = max(minWidth, w)
        fontSize = 0.15
        imageDraw = PIL.ImageDraw.Draw(image)
        # Altered line from WSI DeID rewirtten so font is local to library
        file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'fonts', 'DejaVuSansMono.ttf')
        for iter in range(3, 0, -1):
            try:
                imageDrawFont = PIL.ImageFont.truetype(
                    font=file_path,
                    size=int(fontSize * targetW),
                )
            except IOError:
                try:
                    imageDrawFont = PIL.ImageFont.truetype(
                        font="arial.ttf",
                        size=int(fontSize * targetW),
                    )
                except IOError:
                    imageDrawFont = PIL.ImageFont.load_default()
            if imageDrawFont is None:
                imageDrawFont = PIL.ImageFont.load_default()
            textL, textT, textR, textB = imageDrawFont.getbbox(title)
            textW = textR - textL
            # if there is no width, there is no title
            if not textW:
                return
            textH = textB  # from old imageDraw.textsize(title, imageDrawFont)
            if iter != 1 and (textW > targetW * 0.95 or textW < targetW * 0.85):
                fontSize = fontSize * targetW * 0.9 / textW
        titleH = int(math.ceil(textH * 1.25))
        if square and (w != h or (not previouslyAdded or w != targetW or h < titleH)):
            if targetW < h + titleH:
                targetW = h + titleH
            else:
                titleH = targetW - h
        if previouslyAdded and w == targetW and h >= titleH:
            newImage = image.copy()
        else:
            newImage = PIL.Image.new(mode=self.pil_image_mode, size=(targetW, h + titleH), color=background)
            newImage.paste(image, (int((targetW - w) / 2), titleH))
        imageDraw = PIL.ImageDraw.Draw(newImage)
        imageDraw.rectangle((0, 0, targetW, titleH + self.sep_height), fill=background, outline=None, width=0)
        imageDraw.text(
            xy=(int((targetW - textW) / 2), int((titleH - textH) / 2) + self.sep_height),
            text=title,
            fill=textColor,
            font=imageDrawFont)
        titleH = titleH + self.sep_height*2
        return newImage, titleH

    def check_if_needed_dir_exist(self):
        if not os.path.exists(self.processed_dir) and not os.path.isdir(self.processed_dir):
            print("The folder for the processed output does not exist")

    def create_temp_file_from_buffer(self, buffer, filename):
        '''
        :param buffer: A buffer object with a read interface to create the test_file
        :param ext: the file extension which will be a suffix for the file
        :return: NamedTemporaryFile object that is created using supplied file that provides a name that can be used
        in the workflow
        '''
        ext = os.path.splitext(filename)[1]
        temp_file = tempfile.NamedTemporaryFile(mode='wb', prefix='wsi_deid_',suffix=ext, delete=True)
        temp_file.write(buffer.read())

        return temp_file

    def close_temp_file(self, temp_file):
        '''
        :param temp_file: A NamedTempFile that will be deleted
        :return:
        '''
        temp_file.close()

    def replace_title_if_needed(self, filename, desired_title=None):
        '''

        :param filename: a filename that will be used to generate a new title if desired_title is None
        :param desired_title: a desired title that will be used if not None
        :return:
        '''
        if desired_title is None and desired_title != os.path.basename(filename):
            desired_title = hashlib.blake2b(filename.encode('utf-8')).hexdigest()

        return desired_title

    def get_standard_redactions_format_isyntax(self, item, tileSource, tiffinfo, title):

        metadata = tileSource.getInternalMetadata() or {}
        redactList = {
            "images": {},
            "metadata": {
                "internal;isyntax;scanner_operator_id": generate_system_redaction_list_entry(
                    title
                ),
                "internal;isyntax;barcode": generate_system_redaction_list_entry(
                    title + "|" + get_deid_field(item)
                ),
                "internal;isyntax;software_versions": generate_system_redaction_list_entry(
                    (
                        tileSource.getInternalMetadata()["isyntax"].get(
                            "software_versions", ""
                        )
                        + ' "DSA Redaction %s' % __version__
                        + '"'
                    ).strip()
                ),
            },
        }
        for key in {"acquisition_datetime", "date_of_last_calibration"}:
            if metadata["isyntax"].get(key):
                value = metadata["isyntax"][key]
                if isinstance(value, list):
                    value = value[0]
                value = value.split(".")[0]
                if len(value) < 8:
                    value = None
                else:
                    value = value[:4] + "0101" + ("0" * len(value[8:]))
                redactList["metadata"]["internal;isyntax;%s" % key] = (
                    generate_system_redaction_list_entry(value)
                )
        return redactList

    def create_file_io_write_buffer(self, filename):
        '''
        :param filename: a filename that will be used to create a file buffer
        :return: a file buffer
        '''
        return io.FileIO(filename, 'w')
    
    def redact_format_philips(self, item, output_dir, redactList, title, labelImage, macroImage, preview_metadata=False):
        """
        Redact philips files.

        :param item: the item to redact.
        :param tempdir: a directory for work files and the final result.
        :param redactList: the list of redactions (see get_redact_list).
        :param title: the new title for the item.
        :param labelImage: a PIL image with a new label image.
        :param macroImage: a PIL image with a new macro image.  None to keep or
            redact the current macro image.
        :returns: (filepath, mimetype) The redacted filepath in the tempdir and
            its mimetype.
        """
        tileSource = ImageItem().tileSource(item)
        sourcePath = tileSource._getLargeImagePath()
        tiffinfo = tifftools.read_tiff(sourcePath)
        xmldict = tileSource._tiffDirectories[-1]._description_record
        ifds = tiffinfo['ifds']
        prior_ifds = copy.deepcopy(ifds)
        if redactList.get('area', {}).get('_wsi', {}).get('geojson'):
            ifds = redact_format_aperio_philips_redact_wsi(
                tileSource, ifds, redactList['area']['_wsi']['geojson'], output_dir)
            ImageItem().removeThumbnailFiles(item)
        # redact images from xmldict
        images = philips_tag(xmldict, 'PIM_DP_SCANNED_IMAGES')
        for key, pkey in [('macro', 'MACROIMAGE'), ('label', 'LABELIMAGE')]:
            if key in redactList['images'] and images:
                if key == 'macro' and macroImage:
                    continue
                tag = philips_tag(
                    xmldict, 'PIM_DP_SCANNED_IMAGES', None, 'PIM_DP_IMAGE_TYPE', pkey)
                if tag:
                    tag[-1][0].pop(tag[-1][1])
        # redact images from ifds
        ifds = [ifd for ifd in ifds
                if ifd['tags'].get(tifftools.Tag.ImageDescription.value, {}).get(
                'data', '').split()[0].lower() not in redactList['images'] or (
                    ifd['tags'].get(tifftools.Tag.ImageDescription.value, {}).get(
                        'data', '').split()[0].lower() == 'macro' and macroImage)]

        redactList = copy.copy(redactList)
        title_redaction_list_entry = generate_system_redaction_list_entry(title)
        redactList['metadata']['internal;xml;PIIM_DP_SCANNER_OPERATOR_ID'] = title_redaction_list_entry
        redactList['metadata']['internal;xml;PIM_DP_UFS_BARCODE'] = \
            generate_system_redaction_list_entry(title + '|' + get_deid_field(item))
        # redact general tiff tags
        redact_tiff_tags(ifds, redactList, title)
        add_deid_metadata(item, ifds)
        # remove redacted philips tags
        for key in redactList['metadata']:
            if not key.startswith('internal;xml;'):
                continue
            key = key.split(';', 2)[-1]
            parts = key.split('|') + [None]
            tag = philips_tag(xmldict, parts[0], None, parts[1])
            if tag:
                if parts[1] is not None:
                    tag[-1][2].pop(tag[-1][3])
                else:
                    tag[2].pop(tag[3])
        # Add back philips tags with values
        for key, value in redactList['metadata'].items():
            if not key.startswith('internal;xml;'):
                continue
            key = key.split(';', 2)[-1]
            if value is not None and '|' not in key and key in PhilipsTagElements:
                value = value['value'] if isinstance(value, dict) else value
                plist = xmldict['DataObject']['Attribute']
                pelem = PhilipsTagElements[key]
                entry = {
                    'Name': key,
                    'Group': pelem[0],
                    'Element': pelem[1],
                    'PMSVR': pelem[2],
                    'text': (
                        value if key != 'PIM_DP_UFS_BARCODE' else
                        base64.b64encode(value.encode()).decode()),
                }
                plist.insert(0, entry)
        tag = philips_tag(xmldict, 'PIM_DP_SCANNED_IMAGES')

        with tempfile.TemporaryDirectory() as temp_dir:
            redact_format_philips_replace_macro(
                macroImage, ifds, temp_dir, tag[2][tag[3]]['Array']['DataObject'])
        
            # Insert label image
            if labelImage:
                labelPath = os.path.join(temp_dir, 'label.tiff')
                labelImage.save(labelPath, format='tiff', compression='jpeg', quality=90)
                labelinfo = tifftools.read_tiff(labelPath)
                labelinfo['ifds'][0]['tags'][tifftools.Tag.ImageDescription.value] = {
                    'datatype': tifftools.Datatype.ASCII,
                    'data': 'Label',
                }
                labelinfo['ifds'][0]['tags'][tifftools.Tag.NewSubfileType] = {
                    'data': [1], 'datatype': tifftools.Datatype.LONG}
                ifds.extend(labelinfo['ifds'])
                jpeg = io.BytesIO()
                labelImage.save(jpeg, format='jpeg', quality=90)

                if isinstance(tag[2][tag[3]]['Array']['DataObject'], dict):
                    tag[2][tag[3]]['Array']['DataObject'] = [tag[2][tag[3]]['Array']['DataObject']]
                tag[2][tag[3]]['Array']['DataObject'].append({
                    'Attribute': [{
                        'Name': 'PIM_DP_IMAGE_TYPE',
                        'Group': '0x301D',
                        'Element': '0x1004',
                        'PMSVR': 'IString',
                        'text': 'LABELIMAGE',
                    }, {
                        'Name': 'PIM_DP_IMAGE_DATA',
                        'Group': '0x301D',
                        'Element': '0x1005',
                        'PMSVR': 'IString',
                        'text': base64.b64encode(jpeg.getvalue()).decode(),
                    }],
                    'ObjectType': 'DPScannedImage',
                })
            ifds[0]['tags'][tifftools.Tag.ImageDescription.value] = {
                'datatype': tifftools.Datatype.ASCII,
                'data': xml.etree.ElementTree.tostring(
                    dictToEtree(xmldict), encoding='utf8', method='xml').decode(),
            }

            if preview_metadata:
                return prior_ifds, ifds
            else:
                return self.handle_write_tiff(sourcePath, ifds, output_dir, title, "tiff")

    def redact_format_aperio(self, item: ImageItem, output_dir, redactList, title, labelImage, macroImage, preview_metadata=False):
        """
        Redact aperio files.

        :param item: the item to redact.
        :param output_dir: a directory for work files and the final result.
        :param redactList: the list of redactions (see get_redact_list).
        :param title: the new title for the item.
        :param labelImage: a PIL image with a new label image.
        :param macroImage: a PIL image with a new macro image.  None to keep or
            redact the current macro image.
        :returns: (filepath, mimetype) The redacted filepath in the tempdir and
            its mimetype.
        """

        tileSource = item.tileSource  ##MODDED
        sourcePath = tileSource._getLargeImagePath()
        self.logger.info("Redacting aperio file %s", sourcePath)
        # print(f"Redacting aperio file {sourcePath}")
        tiffinfo = tifftools.read_tiff(sourcePath)
        # print(f"Opened file using tifftools")
        ifds = tiffinfo["ifds"]
        prior_ifds = copy.deepcopy(ifds)
        # print(f"IFDs gotten")
        if redactList.get("area", {}).get("_wsi", {}).get("geojson"):
            # print(f"Calling redact_format_aperio_philips_redact_wsi")
            ifds = redact_format_aperio_philips_redact_wsi(
                tileSource, ifds, redactList["area"]["_wsi"]["geojson"], output_dir
            )
            # print(f"Returned from redact_format_aperio_philips_redact_wsi")
            ## ImageItem().removeThumbnailFiles(item) TBD
        # print(f"Trying aperio_value_list")
        aperioValues = self.aperio_value_list(item, redactList, title)
        # print(f"Aperio values {aperioValues}")
        imageDescription = "|".join(aperioValues)
        # We expect aperio to have the full resolution image in directory 0, the
        # thumbnail in directory 1, lower resolutions starting in 2, and label and
        # macro images in other directories.  Confirm this -- our tiff reader will
        # report the directories used for the full resolution.

        # print(f"Creating TiffFileTileSource")
        tiffSource = TiffFileTileSource(item._largeImagePath)
        # print(f"Created TiffFileTileSource")
        mainImageDir = [
            dir._directoryNum for dir in tiffSource._tiffDirectories[::-1] if dir
        ]
        associatedImages = tileSource.getAssociatedImagesList()
        if mainImageDir != [
            d + (1 if d and "thumbnail" in associatedImages else 0)
            for d in range(len(mainImageDir))
        ]:
            raise Exception("Aperio directories are not as expected")
        firstAssociatedIdx = max(mainImageDir) + 1
        # Set new image description
        # print(f"Setting new image description")
        ifds[0]["tags"][tifftools.Tag.ImageDescription.value] = {
            "datatype": tifftools.Datatype.ASCII,
            "data": imageDescription,
        }
        # redact or adjust thumbnail
        if "thumbnail" in associatedImages:
            if "thumbnail" in redactList["images"]:
                ifds.pop(1)
                firstAssociatedIdx -= 1
            else:
                thumbnailComment = ifds[1]["tags"][tifftools.Tag.ImageDescription.value][
                    "data"
                ]
                thumbnailDescription = "|".join(
                    thumbnailComment.split("|", 1)[0:1] + aperioValues[1:]
                )
                ifds[1]["tags"][tifftools.Tag.ImageDescription.value][
                    "data"
                ] = thumbnailDescription
        # redact other images
        for idx in range(len(ifds) - 1, 0, -1):
            ifd = ifds[idx]
            key = None
            keyparts = (
                ifd["tags"]
                .get(tifftools.Tag.ImageDescription.value, {})
                .get("data", "")
                .split("\n", 1)[-1]
                .strip()
                .split()
            )
            if len(keyparts) and keyparts[0].lower() and not keyparts[0][0].isdigit():
                key = keyparts[0].lower()
            if (
                key is None
                and ifd["tags"].get(tifftools.Tag.NewSubfileType.value)
                and ifd["tags"][tifftools.Tag.NewSubfileType.value]["data"][0]
                & tifftools.Tag.NewSubfileType.bitfield.ReducedImage.value
            ):
                key = (
                    "label"
                    if ifd["tags"][tifftools.Tag.NewSubfileType.value]["data"][0] == 1
                    else "macro"
                )
            if (
                key in redactList["images"]
                or key == "label"
                or (key == "macro" and macroImage)
            ):
                ifds.pop(idx)

        with tempfile.TemporaryDirectory() as temp_dir:
            # Add back label and macro image
            if macroImage:
                redact_format_aperio_add_image(
                    "macro", macroImage, ifds, firstAssociatedIdx, temp_dir, aperioValues
                )
            if labelImage:
                redact_format_aperio_add_image(
                    "label", labelImage, ifds, firstAssociatedIdx, temp_dir, aperioValues
                )
            # redact general tiff tags
            redact_tiff_tags(ifds, redactList, title)
            add_deid_metadata(item, ifds)

            if preview_metadata:
                return prior_ifds, ifds
            else:
                return self.handle_write_tiff(sourcePath, ifds, output_dir, title, "svs")
        

    def get_final_output_path(self, desired_output_path):
        no_desired_output_path = True
        count = 0
        ext = os.path.splitext(desired_output_path)[1]
        output_path = desired_output_path

        while no_desired_output_path:
            if os.path.exists(output_path):
                count += 1
                output_path = desired_output_path.replace(ext, f'_({count}){ext}')
            else:
                no_desired_output_path = False

        return output_path

    def attempt_replace_wsi_file(self, partial_output_path, desired_output_path):
        output_path = self.get_final_output_path(desired_output_path)
        os.replace(partial_output_path, output_path)

        return output_path        

    def handle_write_tiff(self, sourcePath, ifds, output_dir, title, ext_without_dot):
        output_path = os.path.join(output_dir, '{}.{}'.format(title, ext_without_dot))
        final_output_path = self.get_final_output_path(output_path)
        partial_output_path = os.path.join('{}.partial'.format(final_output_path))

        if os.path.exists(partial_output_path):
            os.unlink(partial_output_path)
        
        tracking_file_io = TrackingFileIO(partial_output_path, 'w')

        tifftools.write_tiff(ifds, tracking_file_io)
        tracking_file_io.close()
        output_path = self.attempt_replace_wsi_file(partial_output_path, output_path)

        self.logger.info("Redacted aperio file %s as %s", sourcePath, output_path)
        return output_path, "image/tiff"


    def get_output_path(self, output_dict):
        rename = self.get_rename(output_dict)
        output_path = os.path.join(output_dict['__reserved']['destinationDirectory'], rename)
        output_path = self.get_final_output_path(output_path)
        return output_path

    def add_icon_to_image(self, image, output_dict, output_height=0):
        label_config = output_dict['config']['label']
        if image is None:
            image = PIL.Image.new(self.pil_image_mode, (750, 750))

        image_path = label_config['icon_file']['source']['path']
        if os.path.exists(image_path):
            icon_image = PIL.Image.open(image_path)
        else:
            image_data = base64.b64decode(self.default_image)
            icon_image = PIL.Image.open(io.BytesIO(image_data))

        if icon_image.size[0] > 740:
            new_width  = 740
            new_height = new_width * icon_image.size[1] // icon_image.size[0]
            resize_dim = (new_width, new_height)

            icon_image = icon_image.resize(resize_dim, PIL.Image.LANCZOS)

        position = (image.size[0] // 2 - icon_image.size[0] // 2, output_height + self.sep_height)

        image.paste(icon_image, position)

        output_height = output_height + self.sep_height*2 + icon_image.size[1]

        return image, output_height

    def get_field_data(self, output_dict, field):
        if field == 'rename':
            return self.get_rename(output_dict)
        else:
            field_split = field.split('.')
            data = output_dict
            for subfield in field_split:
                if subfield in data:
                    data = data.get(subfield)
            return data

    def add_qr_code_to_image(self, image, output_dict, desired_title, output_height=0):
        if image is None:
            image = PIL.Image.new(self.pil_image_mode, (750, 750))

        qr_data = {}
        qr_code_string = None

        if 'config' in output_dict and 'label' in output_dict['config'] and 'qr_mode' in output_dict['config']['label']:
            label_config = output_dict['config']['label']
            qr_mode = label_config['qr_mode']['value']
            match qr_mode:
                case 'uuid':
                    qr_code_string = output_dict['__reserved']['uuid']
                case 'column_field':
                    if 'qr_column_field' in label_config and label_config['qr_column_field']['value'] in output_dict:
                        field = label_config['qr_column_field']['value']
                        qr_code_string = str(self.get_field_data(output_dict, field))
                case 'column_fields':
                    if 'qr_column_fields' in label_config:
                        for field_item in label_config['qr_column_fields']:
                            field = field_item['value']
                            qr_data[field] = self.get_field_data(output_dict, field)
                    qr_code_string = base64.b64encode(json.dumps(qr_data).encode('utf-8'))
                case 'user_defined':
                    qr_code_string = desired_title
                case 'none':
                    qr_code_string = ''
                case _:
                    qr_code_string = ''

        if qr_code_string is not None:
            qr_code = qrcode.make(qr_code_string)
            image_cropped = image.crop((0, 0, image.size[0], output_height))
            width = max(qr_code.size[0], image_cropped.size[0])

            if qr_code.size[1] > (750 - output_height - self.sep_height):
                image = PIL.Image.new(self.pil_image_mode, (width, output_height + qr_code.size[1] + self.sep_height*2))
                image.paste(image_cropped, (0,0))
                image.paste(qr_code, (width // 2 - qr_code.size[0] // 2, output_height + self.sep_height))
            else:
                image = PIL.Image.new(self.pil_image_mode, (width, output_height + qr_code.size[1] + self.sep_height*2))
                image.paste(image_cropped, (0,0))
                image.paste(qr_code, (width // 2 - qr_code.size[0] // 2, output_height + self.sep_height))

            output_height = qr_code.size[1] + output_height + self.sep_height + self.sep_height

        return image, output_height

    def get_deid_label(self, output_dict):
        label_config = output_dict['config']['label']

        desired_title = self.get_rename(output_dict)

        if desired_title is not None:
            curItem = ImageItem(output_dict['__reserved']['source']['path'], {"name": desired_title})
        else:
            curItem = ImageItem(output_dict['__reserved']['source']['path'])

        redactList = get_standard_redactions(curItem, desired_title)

        tileSource = curItem.tileSource

        newTitle = get_generated_title(
            curItem
        )

        labelImage = None
        label_geojson = redactList.get("images", {}).get("label", {}).get("geojson")

        ## TO IMPLEMENT...
        if (
            "label" not in redactList["images"]
            and not config.getConfig("always_redact_label")
        ) or label_geojson is not None:
            try:
                labelImage = PIL.Image.open(
                    io.BytesIO(tileSource.getAssociatedImage("label")[0])
                )
            except Exception:
                pass
        if label_geojson is not None and labelImage is not None:
            labelImage = redact_image_area(labelImage, label_geojson)

        output_height = 0

        if label_config['add_text']:
            text = self.get_label_text(output_dict)
            if not isinstance(text, str):
                text = str(text)
            if len(text) > 0:
                labelImage, output_height = self.add_text_to_image(labelImage, text, False, item=curItem)
        if label_config['add_icon']:
            labelImage, output_height = self.add_icon_to_image(labelImage, output_dict, output_height)
        if label_config['add_qr']:
            labelImage, output_height = self.add_qr_code_to_image(labelImage, output_dict, desired_title, output_height)

        if labelImage is not None:
            labelImage = labelImage.crop((0, 0, labelImage.size[0], output_height))
        else:
            labelImage = PIL.Image.new(self.pil_image_mode, (50, 50))

        return labelImage

    def get_label_text(self, output_dict):
        text = ''

        if 'config' in output_dict and 'label' in output_dict['config']:
            label_config = output_dict['config']['label']
            if 'text_column_field' in label_config and label_config['text_column_field'] is not None:
                field = label_config['text_column_field']['value']
                text = self.get_field_data(output_dict, field)

        return text

    def pil_to_base64(self, pil_img):
        """Convert a PIL Image to base64 string."""
        img_buffer = io.BytesIO()
        pil_img.save(img_buffer, format="PNG")  # Adjust format as needed
        base64_str = base64.b64encode(img_buffer.getvalue()).decode('utf-8')
        return 'image/png', base64_str

    def get_rename(self, output_dict):
        temp = ''

        if 'config' in output_dict and 'filename' in output_dict['config']:
            filename_config = output_dict['config']['filename']
            if 'use_uuid' in filename_config and filename_config['use_uuid']:
                if 'uuid' in output_dict['__reserved']:
                    temp += output_dict['__reserved']['uuid']
            elif not filename_config['use_uuid'] and 'rename' in output_dict['__reserved'] and len(output_dict['__reserved']['rename']) > 0:
                temp += output_dict['__reserved']['rename']
            elif 'desired_title' == '' and 'source' in output_dict and 'filename' in output_dict['__reserved']['source']:
                temp += output_dict['__reserved']['source']['filename']
            else:
                temp += 'None'

            if 'use_prefix' in filename_config and filename_config['use_prefix'] and 'prefix' in filename_config:
                temp = filename_config['prefix'] + temp
            if 'use_suffix' in filename_config and filename_config['use_suffix'] and 'suffix' in filename_config:
                temp = temp + filename_config['suffix']

            temp = temp + output_dict['__reserved']['source']['parsed']['ext']

        return temp

    def preview_label(self, output_dict):
        labelImage = self.get_deid_label(output_dict)

        return labelImage

    def preview_macro(self, output_dict):
        macroImage = self.get_deid_macro(output_dict)

        return macroImage

    def return_deid_setup(self, output_dict):
        filename = output_dict['__reserved']['source']['path']

        if output_dict['config']['filename']['use_uuid']:
            desired_title = output_dict['__reserved']['uuid']
        else:
            desired_title = output_dict['__reserved']['rename']

        if desired_title is not None:
            curItem = ImageItem(filename, {"name": desired_title})
        else:
            curItem = ImageItem(filename)

        tileSource = curItem.tileSource

        redactList = get_standard_redactions(curItem, desired_title)

        return curItem, tileSource, redactList

    def get_deid_macro(self, output_dict):
        curItem, tileSource, redactList = self.return_deid_setup(output_dict)

        macroImage = None
        macro_geojson = redactList.get("images", {}).get("macro", {}).get("geojson")
        redact_square_default = "macro" not in redactList[
            "images"
        ] and config.getConfig("redact_macro_square")
        redact_square_manual = "macro" in redactList["images"] and redactList["images"][
            "macro"
        ].get("square")
        redact_square = redact_square_default or redact_square_manual
        if redact_square or macro_geojson:
            try:
                if 'label' in output_dict['config'] and 'wsi' in output_dict['config']['label']:
                    if output_dict['config']['label']['wsi']['save_macro_image']:
                        macroImage = PIL.Image.open(
                            io.BytesIO(tileSource.getAssociatedImage("macro")[0])
                        )
                # ImageItem().removeThumbnailFiles(item)
            except Exception:
                pass

        if macroImage is not None:
            if redact_square:
                macroImage = redact_topleft_square(macroImage)
            elif macro_geojson:
                macroImage = redact_image_area(macroImage, macro_geojson)
        else:
            macroImage = PIL.Image.new(self.pil_image_mode, (50, 50))

        return macroImage

    def redact_format_ometiff(self, item, output_dir, redactList, title, labelImage, macroImage, preview_metadata=False):  # noqa
        """
        Redact ometiff files.

        :param item: the item to redact.
        :param tempdir: a directory for work files and the final result.
        :param redactList: the list of redactions (see get_redact_list).
        :param title: the new title for the item.
        :param labelImage: a PIL image with a new label image.
        :param macroImage: a PIL image with a new macro image.  None to keep or
            redact the current macro image.
        :returns: (filepath, mimetype) The redacted filepath in the tempdir and
            its mimetype.
        """

        import large_image_source_ometiff

        tileSource = ImageItem().tileSource(item)
        sourcePath = tileSource._getLargeImagePath()
        tiffinfo = tifftools.read_tiff(sourcePath)
        ifds = tiffinfo['ifds']
        prior_ifds = copy.deepcopy(ifds)
        if redactList.get('area', {}).get('_wsi', {}).get('geojson'):
            ifds = redact_format_aperio_philips_redact_wsi(
                tileSource, ifds, redactList['area']['_wsi']['geojson'], tempdir)
            ImageItem().removeThumbnailFiles(item)
        tiffSource = large_image_source_ometiff.open(item.filePath)
        mainImageDir = [dir._directoryNum for dir in tiffSource._tiffDirectories[::-1] if dir]
        firstAssociatedIdx = max(mainImageDir) + 1
        # redact other images
        for idx in range(len(ifds) - 1, 0, -1):
            ifd = ifds[idx]
            key = None
            keyparts = ifd['tags'].get(tifftools.Tag.ImageDescription.value, {}).get(
                'data', '').split('\n', 1)[-1].strip().split()
            if len(keyparts) and keyparts[0].lower() and not keyparts[0][0].isdigit():
                key = keyparts[0].lower()
            if (key is None and ifd['tags'].get(tifftools.Tag.NewSubfileType.value) and
                    ifd['tags'][tifftools.Tag.NewSubfileType.value]['data'][0] &
                    tifftools.Tag.NewSubfileType.bitfield.ReducedImage.value):
                key = 'label' if ifd['tags'][
                    tifftools.Tag.NewSubfileType.value]['data'][0] == 1 else 'macro'
            if key in redactList['images'] or key == 'label' or (key == 'macro' and macroImage):
                ifds.pop(idx)
        
        # redact general tiff tags
        redact_tiff_tags(ifds, redactList, title)

        reduced = {}
        refs = {}
        xmldict = tileSource.getInternalMetadata()['omeinfo']
        tileSource._reduceInternalMetadata(reduced, xmldict, refs=refs)
        process = []
        for key in redactList.get('metadata', {}):
            rkey = key
            if key.startswith('internal;omereduced;') and key not in refs:
                rkey = key.split('internal;omereduced;', 1)[1]
            if rkey in refs:
                newval = redactList['metadata'][key].get('value')
                dref, dkey, didx, dskey = refs[rkey]
                process.append((didx, dkey, dskey, rkey, dref, newval))
        process.sort(reverse=True)
        for didx, dkey, dskey, _, dref, newval in process:
            if newval is None:
                if didx is None:
                    del dref[dkey]
                else:
                    dref[dkey][didx:didx + 1] = []
            else:
                if didx is None:
                    if dskey:
                        dref[dkey][dskey] = newval
                    else:
                        dref[dkey] = newval
                else:
                    if dskey:
                        dref[dkey][didx][dskey] = newval
                    else:
                        dref[dkey][didx] = newval
        ifds[0]['tags'][tifftools.Tag.ImageDescription.value] = {
            'datatype': tifftools.Datatype.ASCII,
            'data':
                '<?xml version="1.0" encoding="UTF-8"?>'
                '<OME xmlns="http://www.openmicroscopy.org/Schemas/OME/2016-06" '
                'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" '
                # Should we inject a UUID here?
                # 'UUID="urn:uuid:..." '
                # where that would be the uuid v5 of the sha-1 hash of the rest of
                # the xml
                'xsi:schemaLocation="http://www.openmicroscopy.org/Schemas/OME/2016-06 '
                'http://www.openmicroscopy.org/Schemas/OME/2016-06/ome.xsd">' +
                ''.join(xml.etree.ElementTree.tostring(child, encoding='unicode')
                        for child in dictToEtree(xmldict)) +
                '</OME>',
        }

        with tempfile.TemporaryDirectory() as temp_dir:
            # redact general tiff tags
            add_deid_metadata(item, ifds)

            if preview_metadata:
                return prior_ifds, ifds
            else:
                return self.handle_write_tiff(sourcePath, ifds, output_dir, title, "ome.tif")

    def redact_format_hamamatsu(self, item, output_dir, redactList, title, labelImage, macroImage, preview_metadata=False):
        tileSource = ImageItem().tileSource(item)
        sourcePath = tileSource._getLargeImagePath()
        tiffinfo = tifftools.read_tiff(sourcePath)
        ifds = tiffinfo['ifds']
        prior_ifds = copy.deepcopy(ifds)
        if redactList.get('area', {}).get('_wsi', {}).get('geojson'):
            ifds = redact_format_hamamatsu_redact_wsi(
                tileSource, ifds, redactList['area']['_wsi']['geojson'], tempdir)
            ImageItem().removeThumbnailFiles(item)
        sourceLensTag = tifftools.Tag.NDPI_SOURCELENS.value
        for key in redactList['images']:
            if key == 'macro' and macroImage:
                continue
            lensval = {'macro': -1, 'nonempty': -2}
            ifds = [ifd for ifd in ifds
                    if sourceLensTag not in ifd['tags'] or
                    ifd['tags'][sourceLensTag]['data'][0] != lensval.get(key)]
        redact_tiff_tags(ifds, redactList, title)
        add_deid_metadata(item, ifds)
        propertyTag = tifftools.Tag.NDPI_PROPERTY_MAP.value
        if propertyTag in ifds[0]['tags']:
            propertyList = ifds[0]['tags'][propertyTag]['data'].replace('\r', '\n').split('\n')
            ndpiProperties = {p.split('=')[0]: p.split('=', 1)[1] for p in propertyList if '=' in p}
            for fullkey, value in redactList['metadata'].items():
                if fullkey.startswith('internal;openslide;hamamatsu.'):
                    key = fullkey.split('internal;openslide;hamamatsu.', 1)[1]
                    if key in ndpiProperties:
                        if value is None:
                            del ndpiProperties[key]
                        else:
                            ndpiProperties[key] = value['value'] if isinstance(
                                value, dict) and 'value' in value else value
            propertyList = ['%s=%s\r\n' % (k, v) for k, v in ndpiProperties.items()]
            propertyMap = ''.join(propertyList)
            for ifd in ifds:
                ifd['tags'][tifftools.Tag.NDPI_REFERENCE.value] = {
                    'datatype': tifftools.Datatype.ASCII,
                    'data': title,
                }
                ifd['tags'][propertyTag] = {
                    'datatype': tifftools.Datatype.ASCII,
                    'data': propertyMap,
                }

        with tempfile.TemporaryDirectory() as temp_dir:
            if macroImage:
                redact_format_hamamatsu_replace_macro(
                   macroImage, ifds, temp_dir
                )
            # redact general tiff tags
            add_deid_metadata(item, ifds)

            if preview_metadata:
                return prior_ifds, ifds
            else:
                return self.handle_write_tiff(sourcePath, ifds, output_dir, title, "ndpi")

    def setup_deid(self, output_dict):
        filename = output_dict['__reserved']['source']['path']
        output_dir = output_dict['__reserved']['destinationDirectory']

        filename_config = output_dict['config']['filename']
        wsi_config = output_dict['config']['wsi']

        desired_title = self.get_rename(output_dict)

        if desired_title is not None:
            curItem = ImageItem(filename, {"name": desired_title})
        else:
            curItem = ImageItem(filename)

        redactList = get_standard_redactions(curItem, desired_title)

        newTitle = get_generated_title(
            curItem
        )  # The newtitle is the filename without the extension
        tileSource = curItem.tileSource
        labelImage = self.get_deid_label(output_dict)

        macroImage = self.get_deid_macro(output_dict)

        format = determine_format(tileSource)
        func = None
        if format is not None:
            # fadvise_willneed(curItem)  ## DETERMINE WHAT THIS FUNCTION DOSE..
            func = getattr(self, "redact_format_" + format)
        if func is None:
            return json.dumps({"error": "FORMAT NOT AVAILABLE FOR DEID YET: {}".format(format)})

        return curItem, output_dir, tileSource, redactList, newTitle, labelImage, macroImage, func

    def preview_metadata(self, output_dict):
        curItem, output_dir, tileSource, redactList, newTitle, labelImage, macroImage, func = self.setup_deid(output_dict)

        prior_ifds, new_ifds = func(curItem, output_dir, redactList, newTitle, labelImage, macroImage, preview_metadata=True)

        self.make_ifds_json_serializable(prior_ifds)
        self.make_ifds_json_serializable(new_ifds)

        self.replace_long_data(prior_ifds)
        self.replace_long_data(new_ifds)

        return prior_ifds, new_ifds, redactList

    def make_ifds_json_serializable(self, ifds):
        for ifd in ifds:
            for tag in ifd['tags']:
                if isinstance(ifd['tags'][tag]['data'], bytes):
                    ifd['tags'][tag]['data'] = base64.b64encode(ifd['tags'][tag]['data']).decode('utf-8')


    def replace_long_data(self, ifds):
        for ifd in ifds:
            for tag in ifd['tags']:
                if len(ifd['tags'][tag]['data']) > 10000:
                    ifd['tags'][tag]['data'] = 'Long data length {}'.format(len(ifd['tags'][tag]['data']))

    def perform_deid(self, output_dict):
        curItem, output_dir, tileSource, redactList, newTitle, labelImage, macroImage, func = self.setup_deid(output_dict)
        
        file, mimetype = func(
            curItem, output_dir, redactList, newTitle, labelImage, macroImage
        )
        info = {
            # "format": format,
            "model": model_information(tileSource, format),
            "mimetype": mimetype,
            "redactionCount": {
                key: len([k for k, v in redactList[key].items() if "value" in v and v["value"] is None])
                for key in redactList
                if key != "area"
            },
            "fieldCount": {
                "metadata": metadata_field_count(tileSource, format, redactList),
                "images": len(tileSource.getAssociatedImagesList()),
            },
        }

        return json.dumps({"output_path": file, "info": info})

    def apply_workflow_to_filename_with_output_dir(self, output_dict):
        '''
        Function that applies a de-identification workflow to the given filename.
        Based on wsi_deid, but rewritten to remove dependency on girder to be run locally without docker.

        :param output_dict (A dictionary of information used to deid the file)
        :return: modified file and its corresponding information
        '''

        return self.perform_deid(output_dict)

    def __init__(self, supress_print=False, output_dir=os.path.join('./output/.'), **kwargs):
        self._config = kwargs
        self.supress_print = supress_print
        self.output_dir = output_dir
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(logging.DEBUG)  # Pass everything; let filters handle level-based filtering
        self.logger.setLevel(logging.DEBUG)  # Pass everything; let filters handle level-based filtering